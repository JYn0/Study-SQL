# SQL

Oracle 관리자 화면
http://127.0.0.1:8080/apex/f?p=4950

DB, DB,db

1. ## RDBMS

* SQL

```SQL
SELECT * FROM EMP;
SELECT * FROM DEPT;
SQL에서 제공

-- 한줄 주석
/*
여러줄 주석
*/
```



2. ## DDL

   #### 1) CREATE

   ```sql
   CREATE TABLE T_PRODUCT(
   	ID VARCHAR2(10),
   	PWD VARCHAR2(10),
   	NAME VARCHAR2(20),
       PRICE NUMBER(10,1)
   );
   
   DESC T_PRODUCT;
   ```

   VARCHAR : 가변문자열

   CHAR : 고정문자열 

   데이터 타입 

   PK : 중복해서 값을 넣을 수 없음
   
   #### 2) DROP

   ```sql
DROP TABLE T_PRODUCT;
   ```

   ​	DATA까지 모두 삭제
   
   #### 3) ALTER
   
   제약조건
   
   ```sql
   ALTER TABLE T_PRODUCT ADD (REGDATE DATE);
ALTER TABLE T_PRODUCT DROP(REGDATE);
   ALTER TABLE T_PRODUCT ADD PRIMARY KEY(ID);
   ALTER TABLE T_PRODUCT MODIFY(NAME CHAR(10));
   ALTER TABLE T_PRODUCT RENAME COLUMN NAME TO UNAME;
   ALTER TABLE T_PRODUCT RENAME TO PRODUCT;
   ```
   
   ​	3번 제약조건(CONSTRAINT )



3. ## DML

   데이터 조작(C(insert)R(read)U(update)D(delete))

   #### 1) INSERT
   
   ```sql
   CREATE TABLE T_USER(
   	ID VARCHAR2(10),
   	PWD VARCHAR2(10),
   	NAME VARCHAR2(20)
   );
   ALTER TABLE T_USER ADD PRIMARY KEY(ID);
   INSERT INTO T_USER VALUES ('ID01', 'PWD01', 'MUZI');
   INSERT INTO T_USER VALUES ('ID02', 'PWD02', 'CON');
   INSERT INTO T_USER VALUES ('ID03', 'PWD13', 'RYAN');
   INSERT INTO T_USER VALUES ('ID04', 'PWD04', 'NEO');
   INSERT INTO T_USER VALUES ('ID05', 'PWD05', 'APEACH');
   
   INSERT INTO T_USER () VALUES ()
   ```
   
   ORA-00001: unique constraint (DB.SYS_C007101) violated
   -> 중복된 
   
   STRING 은 ' '
   
   ```sql
   sql
      DESC T_PRODUCT;
      ALTER TABLE T_PRODUCT ADD PRIMARY KEY(ID);
      INSERT INTO T_PRODUCT VALUES();
   INSERT INTO T_PRODUCT VALUES('P01', 'PANTS', 20000, SYSDATE);
      
   INSERT INTO T_PRODUCT (ID, NAME, REGDATE)
      VALUES ('P02', 'PANTS2', SYSDATE);
   
      ALTER TABLE T_PRODUCT MODIFY (PRICE DEFAULT 1000);
      // DEFAULT 값 설정
      INSERT INTO T_PRODUCT (ID, NAME, REGDATE)
   VALUES ('P03', 'PANTS3', SYSDATE);
      // PRICE는 1000 설정
      INSERT INTO T_PRODUCT
      VALUES ('P06', 'PANTS6', 100.322, SYSDATE);
      
      INSERT INTO T_USER VALUES ('ID10', 'PWD10', 'JAYZ');
      ROLLBACK;
      COMMIT;
   ```
   
   
   
   #### 2) SELECT
   
   SELECT 구조 / Alias AS / WHERE  AND  OR  NOT / Operation / ORDER BY / FUNCTION / 술어 / CASE
   
   ```SQL
   SELECT * FROM EMP; //모든 열
   SELECT ENAME, SAL, DEPTNO AS DNO FROM EMP;
   
   SELECT ENAME || JOB AS ENAMEANDJOB FROM EMP;
   SELECT ENAME || ' ' || JOB AS ENAMEANDJOB FROM EMP;
   SELECT ENAME || ' ' || SAL AS ENAMEANDJOB FROM EMP;// SAL이 문자열로 됨
   SELECT DISTINCT (JOB) FROM EMP; //중복제거
   
   SELECT * FROM EMP WHERE JOB = 'MANAGER'; //행 선택
   SELECT * FROM EMP WHERE JOB = 'MANAGER' AND SAL > 2500; //JOB에서 SAL>2500인 조건
   SELECT * FROM EMP WHERE JOB = 'MANAGER' AND SAL > 2500 AND HIREDATE > '04/15.1981';
   //AND 여러번 쓸수있음
   SELECT * FROM EMP WHERE JOB = 'MANAGER' AND ENAME LIKE '%A%';
   // LIKE '%특정단어%' -> 특정단어를 가지고있는 것만 추출, '시작단어%' / '%끝나는단어'
   
   SELECT ENAME, SAL,
   -- 연봉을 계산하시오, SAL 13%, COMM 12% 세금
   ((SAL*12)*0.87)+((NVL(COMM,0)*12)*0.88) AS ANSAL FROM EMP;
   // NVL(COMM, 0)-> COMM에서 NULL값은 0으로 바꿔라
   
   SELECT * FROM EMP WHERE COMM IS NULL; //NULL값인 것만 출력
   SELECT * FROM EMP WHERE COMM IS NOT NULL;
   SELECT * FROM EMP WHERE SAL >= 2000;
   SELECT * FROM EMP WHERE NOT (SAL >= 2000);
   
   SELECT * FROM EMP WHERE SAL < 2000 AND DEPTNO=30 OR ENAME LIKE '%E%';
   SELECT * FROM EMP WHERE JOB = 'CLERK' AND (DEPTNO =10 OR DEPTNO = 20);
   SELECT * FROM EMP WHERE JOB = 'CLERK' AND NOT(DEPTNO =10 OR DEPTNO = 20);
   ```
   
   
   
   ```SQL
   열에 별명 부여하기(Alias AS)
   SELECT ENAME, SAL, DEPTNO AS DNO FROM EMP;
   //DEPTNO -> DNO로 출력
   SELECT ENAME, SAL, SAL*12 AS ASAL, DEPTNO AS DNO FROM EMP;
   //SAL*12 -> ASAL로 출력
   SELECT ENAME, SAL, SAL*12 AS "ANN SAL", DEPTNO AS DNO FROM EMP;
   //SAL*12 -> ANN SAL로 출력("열 명")
   ```
   
   
   
   ```sql
   연산자
   = 같다
   <> NOT, ORACLE에서는 !=가능
   > < >= <=
   ```
   
   
   
   ```SQL
   ORDER BY 재정렬
   SELECT ENAME, SAL FROM EMP ORDER BY SAL ASC;
   SELECT ENAME, SAL FROM EMP WHERE SAL > 1000 AND DEPTNO = 20 ORDER BY SAL DESC;
   // SELECT하고(뽑아내고) 정렬
   
   SELECT ENAME, SAL FROM EMP WHERE SAL > 1000 AND DEPTNO = 20 ORDER BY 2 DESC;
   SELECT ENAME, SAL FROM EMP WHERE SAL > 1000 AND DEPTNO = 20 ORDER BY 1 DESC;
   SELECT ENAME, SAL, SAL*12 FROM EMP WHERE SAL > 1000 AND DEPTNO = 20 ORDER BY 3 ASC;
   //3번항(SLA*12)로 정렬
   
   SELECT * FROM EMP WHERE MGR IS NOT NULL ORDER BY MGR, ENAME;
   //MGR로 정렬하고 ENAME으로 정렬
   SELECT * FROM EMP WHERE COMM IS NOT NULL ORDER BY COMM DESC;
   ```
   
   
   
   ##### 함수
   
   모든 ROW에 적용
   
   * 산술 함수
   
   ```SQL
   SELECT ENAME, SAL, ABS(SAL) FROM EMP; // 절댓값
   SELECT ENAME, SAL, MOD(SAL,3) FROM EMP; // 나머지
   SELECT ENAME, SAL, ROUND (SAL/7,3) AS BONUS FROM EMP; // 반올림
   ROUND(HIREDATE) -> 반올림
   TRUNC(HIREDATE), -> 버림
   ```
   
   * 문자열 함수
   
   ```SQL
   SELECT ENAME || ' ' || JOB AS EJ FROM EMP;
   SELECT LOWER(ENAME) || ' ' || JOB AS EJ FROM EMP; // ENAME 소문자
   SELECT ENAME, SUBSTR(ENAME, 1, 3)FROM EMP; // 1~3 추출
   SELECT ENAME, SUBSTR(ENAME, 1, 3), REPLACE(ENAME,SUBSTR(ENAME, 1, 3), 'AAA') FROM EMP;
   //추출, 123을 AAA로 바꿔라
   
   SELECT ENAME, LENGTH(ENAME) FROM EMP; // 문자열 길이
   
   SELECT ENAME, -- 첫문자만 대문자로 만들어서 가져온다.
   REPLACE(ENAME,SUBSTR(ENAME, 2, LENGTH(ENAME)), LOWER(SUBSTR(ENAME, 2, LENGTH(ENAME))))
   FROM EMP;
   
   SELECT ENAME, SUBSTR(SAL,1,2)*10 FROM EMP; // 숫자는 자동으로 문자열로 변환되기도함
   SELECT ENAME, SAL FROM EMP
   --WHERE DEPTNO = 20 OR DEPTNO = 30;
   WHERE DEPTNO IN(20,30); // IN (A, B) =>  A OR B / NOT IN(A, B) => NOT (A OR B)
   ```
   
   * 날짜 함수
   
   ```SQL
   날짜  SYSDATE, CURRENT_DATE
   시간  CURRENT_TIMESTAMP, TO_CHAR(CURRENT_TIMESTAMP, 'HH:MM:SS')
   SELECT ENAME, TO_CHAR(CURRENT_TIMESTAMP, 'YYYY:MM:DD:HH:MM:SS') AS TIME FROM EMP;
   SELECT ENAME, TO_CHAR(HIREDATE, 'YYYY:MM:DD'), SYSDATE, FROM EMP;
   TO_DATE : STRING -> DATE   TO_DATE('2019/05/31', 'YY:MM:DD')
   TO_STRING : DATE -> STRING TO_STRING()
   INSERT INTO T_PRODUCT VALUES('ID99','PANTS',10000, TO_DATE('2010/10/11','YY:MM:DD'));
   // 2010/10/11을 YY:MM:DD형식으로 넣겠다 -> 10/11/2010
     
   SELECT ENAME, HIREDATE, HIREDATE+1000 FROM EMP; //HIREDATE 1000일후 날짜
   
   SELECT ENAME, HIREDATE, SYSDATE-HIREDATE, MONTHS_BETWEEN (SYSDATE, HIREDATE) FROM EMP;
   // 두 날짜 기준으로 몇 일 /개월이 지났는지
   ```
   
   * 변환 함수
   
   ```SQL
   SELECT ENAME, SAL, COMM , NVL(COMM, 0)+SAL FROM EMP;
   NVL(COLUMN이름, 0) -> NULL이면 0으로 바꿔라
     
   SELECT ENAME, SAL, COMM , NVL2(COMM, '0', '1') FROM EMP;
   //NULL이면 0, 값이 있으면 1로 마킹, 바꾸는 것이 아니라 체크용도
   ```
   
   
   
   ##### 술어
   
   ```SQL
   SELECT ENAME, SAL FROM EMP WHERE SAL LIKE '5%';
   SELECT ENAME, HIREDATE, SYSDATE-HIREDATE, MONTHS_BETWEEN (SYSDATE, HIREDATE) FROM EMP;
   // 두 날짜 기준으로 몇 일 /개월이 지났는지
   SELECT ENAME, SAL FROM EMP WHERE SAL BETWEEN 2000 AND 5000; // 양끝단 포함
   IS NULL / IS NOT NULL / IN <-> NOT IN / LIKE / BETWEEN
   
   -- EXISTS
   -- SCOTT이 소속된 부서의 직원 정보를 조회하시오
   SELECT e1.DEPTNO, e1.ENAME, e1.SAL, d1.DNAME, d1.LOC FROM EMP e1, DEPT d1
   WHERE e1.DEPTNO = d1.DEPTNO
   AND e1.DEPTNO IN(SELECT e2.DEPTNO FROM EMP e2 WHERE e2.ENAME = 'SCOTT')
   -- DALLAS에 있는 직원의 정보를 조회 하시오
   SELECT e1.DEPTNO, e1.ENAME, e1.SAL, d1.DNAME, d1.LOC FROM EMP e1, DEPT d1
   WHERE e1.DEPTNO = d1.DEPTNO 
   AND e1.DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS')
   
   SELECT e1.DEPTNO, e1.ENAME, e1.SAL, d1.DNAME, d1.LOC FROM EMP e1, DEPT d1
   WHERE e1.DEPTNO = d1.DEPTNO
   AND EXISTS(
   SELECT d2.DEPTNO FROM DEPT d2, EMP e2 WHERE d2.DEPTNO = e2.DEPTNO
   AND LOC = 'DALLAS' AND e1.DEPTNO = e2.DEPTNO)
   -- JONES가 속한 JOB의 직원을 조회하시오
   SELECT ENAME, JOB FROM EMP
   WHERE JOB IN(SELECT JOB FROM EMP WHERE ENAME = 'JONES')
   
   SELECT ENAME, JOB FROM EMP e1
   WHERE EXISTS(SELECT JOB FROM EMP e2 WHERE ENAME = 'JONES' AND e1.JOB = e2.JOB)
   ```
   
   
   
   ##### CASE
   
   ```SQL
   SELECT ENAME, 
   CASE WHEN JOB='PRESIDENT'
        THEN '왕'
        WHEN JOB='MANAGER'
        THEN '관리자'
        ELSE '직원'
   END AS GRADE FROM EMP;
   
   SELECT ENAME, 
   CASE WHEN (SAL*12) >= 50000
        THEN '왕'
        WHEN (SAL*12) >= 30000 AND (SAL*12) < 50000
        THEN '관리자'
        ELSE '직원'
   END AS GRADE FROM EMP ORDER BY GRADE;
   ```
   
   ##### 집합함수
   
   집합함수의 결과는 1개(출력), NULL값은 제외  /  날짜는 MIN / MAX만 가능
   
   ```SQL
   SELECT COUNT(ENAME) AS CNT FROM EMP;	// 수
   SELECT SUM(SAL) AS CNT FROM EMP; 		// 합
   AVG - 평균, MAX / MIN
   SELECT COUNT(COMM) AS CNT FROM EMP;			// 4
   SELECT COUNT(NVL(COMM,0)) AS CNT FROM EMP;	// 0
   SELECT AVG(NVL(COMM,0)) AS CNT FROM EMP;
   SELECT ROUND(AVG(NVL(COMM,0)),2) AS CNT FROM EMP;
   
   GROUP BY -> GROUP함수와 같이 사용함(ROW행 갯수가 같게)
   SELECT JOB, SUM(SAL), AVG(SAL), MIN(SAL) FROM EMP GROUP BY JOB;
   SELECT DEPTNO, JOB FROM EMP GROUP BY DEPTNO, JOB; //부서별 JOB의 GROUPING
   SELECT DEPTNO, JOB FROM EMP GROUP BY DEPTNO, JOB ORDER BY DEPTNO ASC;
   
   GROUP함수의 조건문은 HAVING(AND 가능)
   SELECT DEPTNO, JOB, SUM(SAL) FROM EMP GROUP BY DEPTNO, JOB
   HAVING DEPTNO IN(10,20) AND JOB LIKE '%E%' ORDER BY DEPTNO ASC;
   
   SELECT JOB, AVG(SAL) FROM EMP WHERE DEPTNO IN(10,30) GROUP BY JOB; //그룹된 함수 중에서 조건 해당하는 것만
   SELECT JOB, AVG(SAL) FROM EMP GROUP BY JOB HAVING DEPTNO IN(10,30); //HAVING은 JOB에만 가능 그래서 이건 불가
   SELECT JOB, AVG(SAL) FROM EMP GROUP BY JOB HAVING JOB LIKE ('%E%'); //이건 가능
   
   -- JOB별 월급의 평균을 구하시오, JOB별 중에서 E가 들어간 JOB만 조회하시오
   -- GROUP 된 것의 E
   SELECT JOB, AVG(SAL) FROM EMP GROUP BY JOB HAVING JOB LIKE ('%E%');
   -- 그룹된 것에 조건은 HAVING, 그룹핑하고 WHERE절, WHERE절에는 GROUP 못들어감
   -- JOB별 월급의 평균을 구하시오, DEPTNO가 10,20인 직원들을 대상으로 하시오
   SELECT JOB, AVG(SAL) FROM EMP WHERE DEPTNO IN (10,20) GROUP BY JOB;
   
   -- DEPTNO별 JOB별 월급의 평균을 구하시오, 이름에 A가 들어간 직원들을 대상으로 하시오
   -- DEPTNO 20,30인 부서, 또한 월급의 평균이 1000이상인 것을 대상으로 하시오 + COMM 없는사람
   SELECT DEPTNO, JOB, AVG(SAL) FROM EMP
   WHERE ENAME LIKE '%A%' AND COMM IS NULL
   GROUP BY DEPTNO, JOB
   HAVING DEPTNO IN (20,30) AND AVG(SAL) >= 1000
   ORDER BY DEPTNO ASC;
   
   -- 년도 별 입사자의 월급의 평균을 구하시오
   SELECT TO_CHAR(HIREDATE, 'YYYY') ,AVG(SAL) FROM EMP GROUP BY TO_CHAR(HIREDATE, 'YYYY');
   SELECT TO_CHAR(HIREDATE, 'YYYY') ,AVG(SAL) FROM EMP WHERE JOB IN('MANAGER')
   GROUP BY TO_CHAR(HIREDATE, 'YYYY');
   
   SELECT JOB, AVG(SAL) FROM EMP
   -- WHERE JOB IN ('MANAGER')
   GROUP BY JOB
   -- HAVING JOB IN ('MANAGER');
   ```
   
   SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDERBY
   
   
   
   #### 3) DELETE
   
   ```SQL
   DELETE FROM T_USER WHERE ID='ID05';
   DELETE FROM T_USER WHERE <조건>;
   ```
   
   
   
   #### 4) UPDATE
   
   ```sql
   UPDATE T_USER SET PWD='111', NAME='JYn'
   UPDATE T_USER SET PWD='111', NAME='JYn' WHERE ID='ID03'
   ```
   
   
   
   #### VIEW
   
   ```SQL
   CREATE VIEW EMPSALVIEW(ENAME, ANNSAL)
   AS
   SELECT ENAME, (SAL*12) + (NVL(COMM,0)*12) FROM EMP; //ANNSAL에 저장되지않고
   SELECT * FROM EMPSALVIEW; //실행할때 계산하여 직계함수를 만든다.
   // VIEW를 만들고 또 만들 수 있음
   CREATE VIEW ORACLE (TOTALAVG)
   AS
   SELECT AVG(SALAVG) FROM DEPTSAL
   
   CREATE VIEW T_EMP (ENO,ENM,SAL,DNO)
   AS (SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP)
   CREATE VIEW T_DEPT (DNO,DNM,LOC)
   AS (SELECT DEPTNO, DNAME, LOC FROM DEPT)
   SELECT * FROM T_EMP
   SELECT * FROM T_DEPT
   ```
   
   
   
   #### 서브쿼리
   
   ```SQL
   CREATE TABLE ITEM(
       ID VARCHAR2(10),
       NAME VARCHAR2(20),
       CATE NUMBER(10)
   )
   CREATE TABLE CATEGORY(
   	NO NUMBER(10),
       NAME VARCHAR2(20)
   )
   
   ALTER TABLE ITEM ADD PRIMARY KEY(ID);
   ALTER TABLE CATEGORY ADD PRIMARY KEY(NO);
   INSERT INTO CATEGORY VALUES(100,'의류');
   INSERT INTO CATEGORY VALUES(200,'잡화');
   INSERT INTO ITEM VALUES('IT01','바지',400);
   DELETE FROM ITEM WHERE ID='IT01';
   ALTER TABLE ITEM ADD FOREIGN KEY (CATE)
   REFERENCES CATEGORY (NO);
   INSERT INTO ITEM VALUES('IT01','바지',400)// 불가
   
   -- DALLAS에 있는 직원들의 이름을 조회하시오
   SELECT ENAME FROM EMP
   WHERE DEPTNO = 
   (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS'); // <= 서브쿼리
   
   -- SAL의 평균보다 많이받는 사람들의 이름과 SAL을 출력하시오 + DALLAS,CHICAGO에 근무하는 사람
   SELECT ENAME, SAL FROM EMP
   WHERE SAL > (SELECT AVG(SAL) FROM EMP)
   AND DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE LOC IN ('DALLAS', 'CHICAGO'));
   // = -> 1개, IN -> 여러개
   
   SELECT ENAME, SAL, (SELECT AVG(SAL) FROM EMP) FROM EMP;
   // ROW마다 AVG 찍힘
   
   -- 부서 별 월급의 평균을 구하고자 한다. 이 중 전체 평균보다 높은 부서만 출력한다.
   -- 단, NEW YORK 부서는 제외한다.
   SELECT DEPTNO, AVG(SAL) FROM EMP
   GROUP BY DEPTNO
   HAVING AVG(SAL) > (SELECT AVG(SAL) FROM EMP)
   AND DEPTNO NOT IN (SELECT DEPTNO FROM DEPT WHERE LOC = 'NEW YORK');
   
   -- JOB별 평균 월급보다 많이 받는 사람을 조회하시오
   SELECT JOB, ENAME, SAL FROM EMP e1
   WHERE SAL > (
       SELECT AVG(SAL) FROM EMP e2
       WHERE e2.ENAME = e1.ENAME
       GROUP BY JOB
   )
   
   -- 부서 별 월급이 가장 많이 받는 사람의 DEPTNO, ENAME, SAL을 조회하시오
   -- 부서명 ACCOUNTING은 제외하시오
   SELECT DEPTNO, ENAME, SAL FROM EMP e1
   WHERE SAL >= (
       SELECT MAX(SAL) FROM EMP e2
       WHERE e1.DEPTNO = e2.DEPTNO
       AND DEPTNO NOT IN (SELECT DEPTNO FROM DEPT WHERE DNAME = 'ACCOUNTING')
       GROUP BY DEPTNO
   )
   
   -- SCOTT이 소속된 부서의 매니저들의 EMPNO, ENAME, DEPTNO를 조회하시오
   SELECT EMPNO, ENAME, DEPTNO FROM EMP
   WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'SCOTT')
   AND JOB = 'MANAGER'
   
   SELECT EMPNO, ENAME, DEPTNO FROM EMP
   WHERE EMPNO IN (SELECT MGR FROM EMP
       WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'SCOTT'))
   
   SELECT EMPNO, ENAME, DEPTNO FROM EMP e1
   WHERE EMPNO IN (
       SELECT MGR FROM EMP e2
       WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT')
       AND e1.EMPNO = e2.MGR
   )
   ```
   
   
   
   #### JOIN(결합)
   
   ```SQL
   -- EMP를 조회한다. EMPNO, ENAME, DNAME, LOC
   SELECT e.EMPNO, e.ENAME, d.DNAME, d.LOC FROM EMP e, DEPT d
   WHERE e.DEPTNO = d.DEPTNO
   
   -- 지역 별 월급의 평균을 구하시오
   SELECT d.LOC, AVG(e.SAL) FROM EMP e, DEPT d
   WHERE e.DEPTNO = d.DEPTNO
   GROUP BY d.LOC;
   
   -- 지역 별 월급의 평균보다 많이 받는 사람의 LOC, ENAME, SAL을 조회하시오
   -- DALLAS는 제외하시오
   SELECT d.LOC, e.ENAME, e.SAL FROM EMP e, DEPT d
   WHERE e.DEPTNO = d.DEPTNO
   AND d.LOC NOT IN ('DALLAS')
   AND e.SAL > (
       SELECT AVG(SAL) FROM EMP e2, DEPT d2
       WHERE e2.DEPTNO = d2.DEPTNO
       AND d.LOC = d2.LOC
       GROUP BY d.LOC
   )
   
   -- 내가 속한 각 부서 별 월급 평균이상으로 받는 직원들을 조회 하시오
   SELECT ENAME, SAL FROM EMP e1
   WHERE SAL >= (SELECT AVG(SAL) FROM EMP e2
   WHERE e1.DEPTNO = e2.DEPTNO GROUP BY DEPTNO);
   
   -- 내가 속한 각 부서 별 월급 평균이상으로 받는 직원들을 조회 하시오
   -- 단, 부서 명과 지역을 출력하시오
   SELECT e1.DEPTNO, e1.ENAME, e1.SAL, d1.DNAME, d1.LOC FROM EMP e1, DEPT d1
   WHERE e1.DEPTNO = d1.DEPTNO AND SAL >= (SELECT MAX(SAL) FROM EMP e2
   WHERE e1.DEPTNO = e2.DEPTNO GROUP BY DEPTNO) ORDER BY DEPTNO ASC;
   
   INNER JOIN
   
   SELECT e.ENAME, d.LOC FROM EMP e, DEPT d
   WHERE e.DEPTNO = d.DEPTNO // PK와 퍼린키가 연결된 조건으로
   
   SELECT e.ENAME, d.LOC FROM EMP e INNER JOIN DEPT d
   ON e.DEPTNO = d.DEPTNO // ORACLE용
   
   SELECT e.ENAME, d.LOC FROM EMP e, DEPT d
   WHERE e.DEPTNO = d.DEPTNO AND e.JOB = 'MANAGER' AND d.LOC = 'CHICAGO'
   
   SELECT e.ENAME, d.LOC FROM EMP e INNER JOIN DEPT d
   ON (e.DEPTNO = d.DEPTNO) WHERE e.JOB = 'MANAGER' AND d.LOC = 'CHICAGO'
   ```
   
   ### SELF JOIN
   
   ```SQL
   -- 직원의 정보를 출력하시오 EMPNO, ENAME, MNAME을 출력하시오
   SELECT e1.EMPNO AS EMPNO, e1.ENAME AS EMPNO, e2.ENAME AS MNAME FROM EMP e1, EMP e2
   WHERE e1.MGR = e2.EMPNO
   
   INSERT INTO EMP VALUES
   (8888, 'KSK','SALESMAN',7839,TO_DATE('2019/06/01','YYYY/MM/DD'),4000,100,NULL)
   
   SELECT e.ENAME, e.JOB, d.DNAME, d.LOC FROM EMP e, DEPT d
   WHERE e.DEPTNO = d.DEPTNO(+) // + 반대쪽에 없는게 나옴
   
   SELECT e.ENAME, e.JOB, d.DNAME, d.LOC FROM EMP e LEFT OUTER JOIN DEPT d USING(DEPTNO)
   //EMP기준으로 출력
   SELECT e.ENAME, e.JOB, d.DNAME, d.LOC FROM EMP e RIGHT OUTER JOIN DEPT d USING(DEPTNO)
   //EMP말고
   SELECT e.ENAME, e.JOB, d.DNAME, d.LOC FROM EMP e FULL OUTER JOIN DEPT d USING(DEPTNO)
   //양쪽 모두
   ```
   
   
   
   
   
   ### UNION(집합연산)
   
   ```SQL
   -- JONES가 속한 JOB의 직원을 조회하시오 단, 직원의 부서명과 지역을 출력하시오
   SELECT e1.ENAME, e1.JOB, d.DNAME, d.LOC FROM EMP e1, DEPT d
   WHERE e1.DEPTNO = d.DEPTNO AND EXISTS(
   SELECT JOB FROM EMP e2 WHERE ENAME = 'JONES' AND e1.JOB = e2.JOB)
   
   UNION
   -- MANAGER와 SALES 직원들의 이름과 JOB을 조회하시오
   SELECT ENAME, JOB FROM EMP WHERE JOB = 'MANAGER'
   UNION
   SELECT ENAME, JOB FROM EMP WHERE JOB = 'SALESMAN' ORDER BY JOB
   
   SELECT ENAME, JOB FROM EMP WHERE JOB = 'MANAGER'
   UNION
   SELECT ENAME, TO_CHAR(HIREDATE,'YYYY/MM/DD') FROM EMP
   WHERE JOB = 'SALESMAN' ORDER BY JOB
   ```
   
   
   
   #### WINDOW 함수
   
   ```SQL
   SELECT ENAME, SAL FROM EMP ORDER BY SAL
   
   RANK
   SELECT ENAME, SAL, 
   RANK() OVER (ORDER BY SAL DESC) AS RANKING,			// 1 2 3 3 5
   DENSE_RANK() OVER (ORDER BY SAL DESC) AS RANKING,	// 1 2 3 3 4
   ROW_NUMBER() OVER (ORDER BY SAL DESC) AS ROW_NUM	// 1 2 3 4 5
   FROM EMP ORDER BY SAL DESC
   
   SELECT ENAME, SAL, ROW_NUM 
   FROM(SELECT ENAME, SAL, ROW_NUMBER() OVER (ORDER BY SAL DESC) AS ROW_NUM FROM EMP)
   WHERE ROW_NUM <= 5
   
   SELECT ENAME, SAL,
   ROUND((SELECT AVG(SAL) FROM EMP),2) AS ASAL,
   RANK,
   (SELECT COUNT(*) FROM EMP) AS TOTAL
   FROM(SELECT ENAME, SAL, RANK() OVER (ORDER BY SAL DESC) AS RANK FROM EMP)
   WHERE RANK <= 5
   
   
   ROLLUP
   SELECT JOB, SUM(SAL) FROM EMP GROUP BY ROLLUP(JOB) //집계
   ```
   
   
